





6) Slug discipline — case‑insensitive uniques + validare strictă + aliniere la f_ltree_label()

Fixează slug‑urile ca identități canonice: unicitate pe lower(slug) pentru neurons și bundles; CHECK cu regex; normalizare deterministă; pod către arbore: slug → ltree label compatibil cu f_ltree_label() (numele de noduri). 

A) Migrare idempotentă — 27_slug_ci_and_validation.sql

Rulează înainte de a crea indexurile unice: normalizează și rezolvă coliziunile.

-- 27_slug_ci_and_validation.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 1) VALIDATOR: regex canonic (lowercase, cuvinte despărțite de minus)
--    ^[a-z0-9]+(-[a-z0-9]+)*$
CREATE OR REPLACE FUNCTION public.f_is_valid_slug(s text)
RETURNS boolean
LANGUAGE sql IMMUTABLE AS $$
  SELECT s IS NOT NULL AND s ~ '^[a-z0-9]+(-[a-z0-9]+)*$'
$$;

-- 2) NORMALIZATOR: 'Any' → 'any', spații/punctuație → '-', compactează '-', taie marginile.
--    Dacă rezultatul e gol → 'n-' + hash scurt determinist.
CREATE OR REPLACE FUNCTION public.f_slugify(src text)
RETURNS text
LANGUAGE plpgsql IMMUTABLE AS $$
DECLARE
  s text := lower(coalesce(src,''));
BEGIN
  s := replace(s, '_', '-');                          -- underscore → minus
  s := regexp_replace(s, '[^a-z0-9-]+', '-', 'g');    -- orice altceva → minus
  s := regexp_replace(s, '-{2,}', '-', 'g');          -- compactează --
  s := regexp_replace(s, '^-+|-+$', '', 'g');         -- taie marginile
  IF s = '' THEN
    s := 'n-' || substr(encode(digest(coalesce(src,''), 'sha1'), 'hex'), 1, 8);
  END IF;
  RETURN s;
END $$;

-- 3) ALIGN: slug → etichetă de arbore compatibilă cu f_ltree_label()
--    (în arbore sunt permise [a-z0-9_]; prefix 'n_' dacă începe cu cifră)
--    Refolosește f_ltree_label() definită în schema arborelui. :contentReference[oaicite:1]{index=1}
CREATE OR REPLACE FUNCTION public.f_slug_to_ltree_label(s text)
RETURNS text
LANGUAGE sql IMMUTABLE AS $$
  SELECT public.f_ltree_label( replace(public.f_slugify(s), '-', '_') )
$$;

-- 4) TRIGGERE: normalizează slug la INSERT/UPDATE pentru NEURONS și BUNDLES
CREATE OR REPLACE FUNCTION public.trg_normalize_slug_neurons()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.slug := public.f_slugify(NEW.slug);
  IF NOT public.f_is_valid_slug(NEW.slug) THEN
    RAISE EXCEPTION 'Invalid slug format for neuron: %', NEW.slug;
  END IF;
  RETURN NEW;
END $$;

CREATE OR REPLACE FUNCTION public.trg_normalize_slug_bundles()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.slug := public.f_slugify(NEW.slug);
  IF NOT public.f_is_valid_slug(NEW.slug) THEN
    RAISE EXCEPTION 'Invalid slug format for bundle: %', NEW.slug;
  END IF;
  RETURN NEW;
END $$;

-- atașează triggerele (idempotent)
DROP TRIGGER IF EXISTS neurons_normalize_slug ON public.neurons;
CREATE TRIGGER neurons_normalize_slug
BEFORE INSERT OR UPDATE OF slug ON public.neurons
FOR EACH ROW EXECUTE FUNCTION public.trg_normalize_slug_neurons();

DROP TRIGGER IF EXISTS bundles_normalize_slug ON public.bundles;
CREATE TRIGGER bundles_normalize_slug
BEFORE INSERT OR UPDATE OF slug ON public.bundles
FOR EACH ROW EXECUTE FUNCTION public.trg_normalize_slug_bundles();

-- 5) CHECK constraints pe formatul slug (hard rule)
ALTER TABLE public.neurons  DROP CONSTRAINT IF EXISTS ck_neurons_slug_format;
ALTER TABLE public.neurons  ADD  CONSTRAINT ck_neurons_slug_format  CHECK (public.f_is_valid_slug(slug));

ALTER TABLE public.bundles  DROP CONSTRAINT IF EXISTS ck_bundles_slug_format;
ALTER TABLE public.bundles  ADD  CONSTRAINT ck_bundles_slug_format  CHECK (public.f_is_valid_slug(slug));

-- 6) BACKFILL: normalizează existenții (înaintea indexurilor unice)
UPDATE public.neurons  SET slug = public.f_slugify(slug)  WHERE slug IS NOT NULL AND slug <> public.f_slugify(slug);
UPDATE public.bundles  SET slug = public.f_slugify(slug)  WHERE slug IS NOT NULL AND slug <> public.f_slugify(slug);

-- 7) DE-DUPE după normalizare (dacă apar coliziuni pe lower(slug))
--    sufixelor li se atașează '-'+hash(id) pentru stabilitate.
WITH d AS (
  SELECT id, slug, lower(slug) AS lslug,
         ROW_NUMBER() OVER (PARTITION BY lower(slug) ORDER BY id) AS rn
  FROM public.neurons
)
UPDATE public.neurons n
   SET slug = n.slug || '-' || substr(encode(digest(n.id::text, 'sha1'),'hex'),1,6)
  FROM d WHERE n.id = d.id AND d.rn > 1;

WITH d AS (
  SELECT id, slug, lower(slug) AS lslug,
         ROW_NUMBER() OVER (PARTITION BY lower(slug) ORDER BY id) AS rn
  FROM public.bundles
)
UPDATE public.bundles b
   SET slug = b.slug || '-' || substr(encode(digest(b.id::text, 'sha1'),'hex'),1,6)
  FROM d WHERE b.id = d.id AND d.rn > 1;

-- 8) INDEXURI UNICE case‑insensitive
--    (păstrează UNIQUE existent pe slug; acesta e case-sensitive și nu strică.
--     indexurile noi previn dubluri 'Test' vs 'test'.) :contentReference[oaicite:2]{index=2}
CREATE UNIQUE INDEX IF NOT EXISTS uq_neurons_slug_ci ON public.neurons (lower(slug));
CREATE UNIQUE INDEX IF NOT EXISTS uq_bundles_slug_ci ON public.bundles (lower(slug));

-- 9) (OPȚIONAL, recomandat) Istoric sluguri — aplică aceleași reguli
--    dacă ai tabelul neuron_slugs creat în guard-ul legal (§4).
ALTER TABLE IF EXISTS public.neuron_slugs DROP CONSTRAINT IF EXISTS ck_neuron_slugs_slug_format;
ALTER TABLE IF EXISTS public.neuron_slugs ADD  CONSTRAINT ck_neuron_slugs_slug_format CHECK (public.f_is_valid_slug(slug));

CREATE UNIQUE INDEX IF NOT EXISTS uq_neuron_slugs_slug_ci ON public.neuron_slugs (lower(slug));


Ancore: neurons.slug și bundles.slug există deja și sunt UNIQUE (case‑sensitive); adăugăm unicitate pe lower(slug) + CHECK și normalize. f_ltree_label() e deja definită în arbore; funcția f_slug_to_ltree_label() replică exact disciplina ei, schimbând -→_. 

B) Interop explicit cu arborele (contract „slug ↔ label”)

Regulă: când ai nevoie de etichetă de arbore pentru un slug, folosește f_slug_to_ltree_label(slug) — e compatibilă cu f_ltree_label() (etichetele din arbore sunt [a-z0-9_] și evită începutul cu cifră). 

-- exemple rapide
SELECT public.f_slugify('AI / Prompt—Engineering! 101')          AS slug;   -- ai-prompt-engineering-101
SELECT public.f_slug_to_ltree_label('ai-prompt-engineering-101') AS label;  -- ai_prompt_engineering_101

C) Smoke‑tests (trec/nu trec)
-- OK
INSERT INTO public.neurons(slug,title,summary,content_full,price_cents,category,tags)
VALUES ('ai-frameworks','X','prev','full',2900,'cat','{}');

-- FAIL: invalid (uppercase / caractere ilegale)
INSERT INTO public.neurons(slug,title,summary,content_full,price_cents,category,tags)
VALUES ('AI Frameworks','X','prev','full',2900,'cat','{}');  -- trigger normalizează → 'ai-frameworks'; dacă deja există → coliziune ci

-- FAIL: dublură case-insensitive
INSERT INTO public.bundles(slug,title,description,price_cents,required_tier)
VALUES ('Starter-Pack','Y','desc',11900,'architect');        -- eșuează dacă există 'starter-pack' (uq_*_slug_ci)

-- ALIGN cu arbore
SELECT public.f_ltree_label('AI Frameworks');                -- ai_frameworks
SELECT public.f_slug_to_ltree_label('ai-frameworks');        -- ai_frameworks (identic)

D) De ce acum (și aici)

Neuroni și bundles sunt suprafețe publice; slug‑ul este identitatea comercială → închide spațiul pentru dubluri „Test/test” sau forme cu spații/punctuație. 

Arborele folosește f_ltree_label() pentru path determinist; slug → label trebuie să fie o funcție stabilă, nu o convenție informală. 

Verdict simbolic

Canonicalizează numele — slugul devine lege, nu opinie.






7) Căutare robustă — unaccent + tsvector GENERAT (idempotent, public‑safe)

Obiectiv: treci de la index pe expresie dinamică la coloană tsv generată & STORED, cu unaccent și GIN, apoi expui căutarea printr‑un RPC public care respectă vitrina (v_neuron_public) — zero risc de leak la content_full. Înlocuiește indexul vechi pe to_tsvector(...) (english) din migrarea inițială. 
 

A) Migrare completă — 28_search_unaccent_tsv.sql
-- 28_search_unaccent_tsv.sql
CREATE EXTENSION IF NOT EXISTS unaccent;

-- 1) Curățare: indexul vechi pe expresie (a fost english; acum e STORED)
DROP INDEX IF EXISTS idx_neurons_search;

-- 2) Coloană GENERATĂ & STORED (accent-insensitive, config 'simple')
ALTER TABLE public.neurons
  DROP COLUMN IF EXISTS tsv,
  ADD  COLUMN tsv tsvector
  GENERATED ALWAYS AS (
    to_tsvector(
      'simple',
      unaccent(coalesce(title,'') || ' ' || coalesce(summary,''))
    )
  ) STORED;

-- 3) GIN pe tsv
CREATE INDEX IF NOT EXISTS idx_neurons_tsv_gin
  ON public.neurons
  USING GIN (tsv);

-- 4) (opțional) btree pe created_at pentru tie-break la ordonare
CREATE INDEX IF NOT EXISTS idx_neurons_created_at ON public.neurons(created_at DESC);


Note solide:
– Țintești accent‑insensitive prin unaccent(...) în coloană generată; GIN(tsv) devine stabil, spre deosebire de indexul anterior pe expresie. 

– simple ≈ fără stemming — potrivit mixului RO/EN; ai preview public doar din v_neuron_public, full prin RPC separat. 

B) RPC public pentru căutare — rpc_search_neurons (rank + snippet, fără leak)

Contract: intrare q text, limit int=20, offset int=0; întoarce doar câmpurile din vitrină + rank + snippet. Rulează SECURITY DEFINER, se auto‑filtrează prin v_neuron_public (doar published=true). 

-- 28_search_unaccent_tsv.sql (continuare)

-- RPC public: căutare accent-insensitive cu plainto_tsquery('simple', unaccent(:q))
CREATE OR REPLACE FUNCTION public.rpc_search_neurons(
  p_q text,
  p_limit int DEFAULT 20,
  p_offset int DEFAULT 0
)
RETURNS TABLE(
  id uuid,
  slug text,
  title text,
  summary text,
  required_tier plan_tier,
  price_cents int,
  rank real,
  snippet text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  q tsquery := NULL;
BEGIN
  -- normalizează interogarea; respinge zgomotul foarte scurt
  p_q := btrim(coalesce(p_q,''));
  IF length(p_q) < 2 THEN
    RETURN;
  END IF;

  -- compune tsquery: plain → simplu, robust; unaccent pe input
  q := plainto_tsquery('simple', unaccent(p_q));

  RETURN QUERY
  SELECT
    v.id, v.slug, v.title, v.summary, v.required_tier, v.price_cents,
    ts_rank(n.tsv, q) AS rank,
    -- headline pe summary (2 fragmente compacte)
    ts_headline(
      'simple',
      unaccent(v.summary),
      q,
      'MaxFragments=2, MinWords=5, MaxWords=12, HighlightAll=FALSE'
    ) AS snippet
  FROM public.v_neuron_public v
  JOIN public.neurons n ON n.id = v.id   -- asigură published=true prin view
  WHERE n.tsv @@ q
  ORDER BY rank DESC, v.title ASC
  LIMIT greatest(1, coalesce(p_limit,20))
  OFFSET greatest(0, coalesce(p_offset,0));
END
$$;

-- expunere: public (anon + authenticated) — doar view fields
REVOKE ALL ON FUNCTION public.rpc_search_neurons(text,int,int) FROM PUBLIC, anon, authenticated;
GRANT EXECUTE ON FUNCTION public.rpc_search_neurons(text,int,int) TO anon, authenticated;

C) Exemple de interogare (copy/paste)
-- accent-insensitive (căutare "arhitectura" găsește "arhitectură")
SELECT slug, title, rank
FROM public.rpc_search_neurons('arhitectura', 10, 0);

-- query scurt dar valid (>=2 char)
SELECT slug, title, snippet
FROM public.rpc_search_neurons('ai', 10, 0);

-- paginare
SELECT slug, title
FROM public.rpc_search_neurons('prompt systems', 20, 20);


Back‑compat: rutele /search din FE lovesc acum RPC‑ul; rămâi aliniat cu separarea „preview vs full” implementată în schema views/RPC. 

D) Teste & verificări (sanity)
-- 1) ANALYZE pentru planuri sănătoase
ANALYZE public.neurons;

-- 2) Verifică folosirea indexului GIN
EXPLAIN ANALYZE
SELECT id FROM public.neurons
WHERE tsv @@ plainto_tsquery('simple', unaccent('arhitectura'));

-- 3) Smoke pe RPC (anon/auth)
SELECT count(*) FROM public.rpc_search_neurons('architect', 5, 0);

E) Hardening opțional (extensii previzibile)

websearch_to_tsquery pentru operatori „Google‑like” ("fraze", A OR B, -excluderi), dacă vrei query parsing mai bogat: schimbă plainto_tsquery ↔ websearch_to_tsquery (păstrezi unaccent).

tags în căutare: extinde tsv la title||summary||array_to_string(tags,' ') dacă vrei să intri și pe etichete (menții GIN pe aceeași coloană).

trigram prefix (pg_trgm) pentru completare instant; ține‑l separat de FTS (nu îl amesteca în această migrare).

F) Integrare frontend (Supabase client; minimal)
// search.ts
import { createClient } from '@supabase/supabase-js';
const supabase = createClient(SUPA_URL, SUPA_ANON);

export async function searchNeurons(q: string, limit = 20, offset = 0) {
  return supabase
    .rpc('rpc_search_neurons', { p_q: q, p_limit: limit, p_offset: offset });
}
// UI: afișează title/summary/snippet; nu expune content_full aici.


Roluri: anon/authenticated pot apela RPC; conținutul full rămâne exclusiv pe rpc_get_neuron_full (cu rate‑limit + watermark). 

Verdict simbolic

Fă din căutare o decizie, nu o expresie: tokenizare simplă, accent‑insensitivă, index stocat, livrare controlată.





